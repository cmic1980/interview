# 新生代和老年代、并行和并发


## 新生代和老年代

从内存回收的角度来看，一般我们可以将Java堆分为：新生代和老年代。 
新生代再细分可以分为 Eden空间、From Survivor空间、To Survivor空间


## 新生代

IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor 。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。

简单可以总结为：大部分的对象在创建后很快就不再使用，于是被年轻代的GC机制清理掉，这个GC机制被称为Minor GC或叫Young GC。采用的是复制-回收算法（Eden：Survivor = 8:1）


## 老年代
老年代保存的 一般都是从新生代经过N次回收后任然还存活的对象实例。一般这个区域的对象基本很少是需要清理的，所以如果采用的是复制算法，那么就很浪费空间和性能了。当年老代内存不足时，将执行Major GC，也叫 Full GC。 
在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC


## 并发和并行
- 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
- 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。

